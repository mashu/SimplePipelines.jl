<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SimplePipelines.jl</title><meta name="title" content="Tutorial · SimplePipelines.jl"/><meta property="og:title" content="Tutorial · SimplePipelines.jl"/><meta property="twitter:title" content="Tutorial · SimplePipelines.jl"/><meta name="description" content="Documentation for SimplePipelines.jl."/><meta property="og:description" content="Documentation for SimplePipelines.jl."/><meta property="twitter:description" content="Documentation for SimplePipelines.jl."/><meta property="og:url" content="https://mashu.github.io/SimplePipelines.jl/tutorial/"/><meta property="twitter:url" content="https://mashu.github.io/SimplePipelines.jl/tutorial/"/><link rel="canonical" href="https://mashu.github.io/SimplePipelines.jl/tutorial/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SimplePipelines.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Steps"><span>Steps</span></a></li><li><a class="tocitem" href="#Sequential-Execution:"><span>Sequential Execution: <code>&gt;&gt;</code></span></a></li><li><a class="tocitem" href="#Pipe-(),-same-input-(),-and-broadcast-(.)"><span>Pipe (<code>|&gt;</code>), same input (<code>&gt;&gt;&gt;</code>), and broadcast (<code>.&gt;&gt;</code>)</span></a></li><li><a class="tocitem" href="#Parallel-Execution:-and"><span>Parallel Execution: <code>&amp;</code></span></a></li><li><a class="tocitem" href="#Complex-DAGs"><span>Complex DAGs</span></a></li><li><a class="tocitem" href="#Fallback:"><span>Fallback: <code>|</code></span></a></li><li><a class="tocitem" href="#Retry:-or-Retry()"><span>Retry: <code>^</code> or <code>Retry()</code></span></a></li><li><a class="tocitem" href="#Branch-(Conditional)"><span>Branch (Conditional)</span></a></li><li><a class="tocitem" href="#Timeout"><span>Timeout</span></a></li><li><a class="tocitem" href="#ForEach-(pattern-or-collection)"><span>ForEach (pattern or collection)</span></a></li><li><a class="tocitem" href="#Reduce-(Combine)"><span>Reduce (Combine)</span></a></li><li><a class="tocitem" href="#Running-Pipelines"><span>Running Pipelines</span></a></li><li><a class="tocitem" href="#Checking-Results"><span>Checking Results</span></a></li><li><a class="tocitem" href="#Mixing-Shell-and-Julia"><span>Mixing Shell and Julia</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../design/">Design</a></li><li><a class="tocitem" href="../development/">Development</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mashu/SimplePipelines.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mashu/SimplePipelines.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Steps"><a class="docs-heading-anchor" href="#Steps">Steps</a><a id="Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Steps" title="Permalink"></a></h2><p>A <strong>Step</strong> is the basic unit of work—either a shell command or Julia function.</p><h3 id="Shell-Commands"><a class="docs-heading-anchor" href="#Shell-Commands">Shell Commands</a><a id="Shell-Commands-1"></a><a class="docs-heading-anchor-permalink" href="#Shell-Commands" title="Permalink"></a></h3><pre><code class="language-julia hljs">using SimplePipelines

# Direct command (anonymous step)
step = @step sh&quot;samtools sort input.bam&quot;

# Named step
step = @step sort = sh&quot;samtools sort input.bam&quot;

# Shell features (&gt;, |, &amp;&amp;) - use sh&quot;...&quot;
step = @step sort = sh&quot;sort data.txt | uniq &gt; sorted.txt&quot;</code></pre><h3 id="Julia-Functions"><a class="docs-heading-anchor" href="#Julia-Functions">Julia Functions</a><a id="Julia-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Functions" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Anonymous function step
step = @step () -&gt; process_data()

# Named function step
step = @step analyze = () -&gt; run_analysis(&quot;data.csv&quot;)</code></pre><h3 id="File-Dependencies-(Optional)"><a class="docs-heading-anchor" href="#File-Dependencies-(Optional)">File Dependencies (Optional)</a><a id="File-Dependencies-(Optional)-1"></a><a class="docs-heading-anchor-permalink" href="#File-Dependencies-(Optional)" title="Permalink"></a></h3><p>Track input/output files for validation:</p><pre><code class="language-julia hljs">@step align(&quot;reads.fq&quot; =&gt; &quot;aligned.bam&quot;) = sh&quot;bwa mem ref.fa reads.fq &gt; aligned.bam&quot;  # sh&quot;...&quot; for redirection</code></pre><h2 id="Sequential-Execution:"><a class="docs-heading-anchor" href="#Sequential-Execution:">Sequential Execution: <code>&gt;&gt;</code></a><a id="Sequential-Execution:-1"></a><a class="docs-heading-anchor-permalink" href="#Sequential-Execution:" title="Permalink"></a></h2><p>The <code>&gt;&gt;</code> operator chains steps—each waits for the previous to complete. When the next node is a <strong>function step</strong>, it receives the previous step&#39;s output (or the current branch context inside <code>ForEach</code>):</p><pre><code class="language-julia hljs"># Chain commands directly (anonymous steps)
pipeline = sh&quot;download data.txt&quot; &gt;&gt; sh&quot;process data.txt&quot; &gt;&gt; sh&quot;upload results.txt&quot;

# Data passing: function steps receive previous output
download(id) = &quot;data_$(id).csv&quot;
process(path) = read(path, String)  # receives path from download
pipeline = @step dl = download &gt;&gt; @step proc = process

# Or define named steps, then chain
step_a = @step step_a = sh&quot;download data.txt&quot;
step_b = @step step_b = sh&quot;process data.txt&quot;
step_c = @step step_c = sh&quot;upload results.txt&quot;
pipeline = step_a &gt;&gt; step_b &gt;&gt; step_c</code></pre><h2 id="Pipe-(),-same-input-(),-and-broadcast-(.)"><a class="docs-heading-anchor" href="#Pipe-(),-same-input-(),-and-broadcast-(.)">Pipe (<code>|&gt;</code>), same input (<code>&gt;&gt;&gt;</code>), and broadcast (<code>.&gt;&gt;</code>)</a><a id="Pipe-(),-same-input-(),-and-broadcast-(.)-1"></a><a class="docs-heading-anchor-permalink" href="#Pipe-(),-same-input-(),-and-broadcast-(.)" title="Permalink"></a></h2><p>When the left has <strong>one</strong> output, <code>&gt;&gt;</code>, <code>|&gt;</code>, and <code>.&gt;&gt;</code> all pass that value to the next (function) step. When the left has <strong>multiple</strong> outputs (e.g. ForEach, Parallel), they differ:</p><table><tr><th style="text-align: left">Left side</th><th style="text-align: left"><span>$&gt;&gt;$</span></th><th style="text-align: left">Pipe</th><th style="text-align: left"><span>$.&gt;&gt;$</span></th></tr><tr><td style="text-align: left">Single output</td><td style="text-align: left">step(one value)</td><td style="text-align: left">step(one value)</td><td style="text-align: left">step(one value)</td></tr><tr><td style="text-align: left">Multi output</td><td style="text-align: left">step(<strong>last</strong> only)</td><td style="text-align: left">step(<strong>vector</strong> of all)</td><td style="text-align: left">step <strong>per branch</strong> (one call each)</td></tr></table><ul><li><strong><code>a |&gt; b</code></strong> — Run <code>a</code>, then run <code>b</code> with <code>a</code>&#39;s output(s). RHS must be a function step. Multi-branch → one call with a vector.</li><li><strong><code>a &gt;&gt;&gt; b</code></strong> — Run <code>a</code> then <code>b</code> with the <strong>same</strong> input (e.g. inside ForEach, both get the branch id). Use when the next step should not receive <code>a</code>&#39;s output.</li><li><strong><code>a .&gt;&gt; b</code></strong> — Attach <code>b</code> to <strong>each branch</strong> of <code>a</code>. Each branch runs as <code>branch &gt;&gt; b</code>; you don&#39;t wait for all of <code>a</code> to finish before starting <code>b</code> on completed branches.</li></ul><pre><code class="language-julia hljs"># Pipe: pass download output to process
fetch = @step fetch = `echo &quot;content&quot;`
process(x) = uppercase(String(x))
pipeline = fetch |&gt; @step process = process

# Same input (e.g. in ForEach): both steps get the id
ForEach([1, 2]) do id
    @step first = (x -&gt; &quot;a_$(x)&quot;) &gt;&gt;&gt; @step second = (x -&gt; &quot;b_$(x)&quot;)
end

# Broadcast: process each branch output immediately
ForEach([&quot;a&quot;, &quot;b&quot;]) do x
    Step(Symbol(&quot;echo_&quot;, x), `echo $x`)
end .&gt;&gt; @step process = (s -&gt; &quot;got_&quot; * strip(String(s)))</code></pre><h2 id="Parallel-Execution:-and"><a class="docs-heading-anchor" href="#Parallel-Execution:-and">Parallel Execution: <code>&amp;</code></a><a id="Parallel-Execution:-and-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Execution:-and" title="Permalink"></a></h2><p>The <code>&amp;</code> operator groups steps to run concurrently:</p><pre><code class="language-julia hljs"># Parallel steps (anonymous)
parallel = sh&quot;task_a&quot; &amp; sh&quot;task_b&quot; &amp; sh&quot;task_c&quot;

# Named steps in parallel, then merge
sample_1 = @step s1 = sh&quot;process sample1&quot;
sample_2 = @step s2 = sh&quot;process sample2&quot;
sample_3 = @step s3 = sh&quot;process sample3&quot;
merge_results = @step merge = sh&quot;merge outputs&quot;
pipeline = (sample_1 &amp; sample_2 &amp; sample_3) &gt;&gt; merge_results</code></pre><h2 id="Complex-DAGs"><a class="docs-heading-anchor" href="#Complex-DAGs">Complex DAGs</a><a id="Complex-DAGs-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-DAGs" title="Permalink"></a></h2><p>Combine <code>&gt;&gt;</code> and <code>&amp;</code> for arbitrary graphs.</p><h3 id="Diamond-Pattern"><a class="docs-heading-anchor" href="#Diamond-Pattern">Diamond Pattern</a><a id="Diamond-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Diamond-Pattern" title="Permalink"></a></h3><pre><code class="nohighlight hljs">       ┌── analyze_a ──┐
 fetch─┤               ├── report
       └── analyze_b ──┘</code></pre><pre><code class="language-julia hljs">fetch = @step fetch = sh&quot;echo &#39;a,b\n1,2&#39; &gt; data.csv&quot;
analyze_a = @step a = sh&quot;wc -l data.csv&quot;
analyze_b = @step b = sh&quot;wc -c data.csv&quot;
report = @step report = () -&gt; &quot;done&quot;

pipeline = fetch &gt;&gt; (analyze_a &amp; analyze_b) &gt;&gt; report
run(pipeline)</code></pre><h3 id="Multi-Stage-Parallel"><a class="docs-heading-anchor" href="#Multi-Stage-Parallel">Multi-Stage Parallel</a><a id="Multi-Stage-Parallel-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Stage-Parallel" title="Permalink"></a></h3><p>For graphs with multiple fork-join points, compose in stages:</p><pre><code class="nohighlight hljs">     ┌─ b ─┐     ┌─ e ─┐
  a ─┤     ├─ d ─┤     ├─ g
     └─ c ─┘     └─ f ─┘</code></pre><pre><code class="language-julia hljs">a = @step a = sh&quot;step_a&quot;
b = @step b = sh&quot;step_b&quot;
c = @step c = sh&quot;step_c&quot;
d = @step d = sh&quot;step_d&quot;
e = @step e = sh&quot;step_e&quot;
f = @step f = sh&quot;step_f&quot;
g = @step g = sh&quot;step_g&quot;

pipeline = a &gt;&gt; (b &amp; c) &gt;&gt; d &gt;&gt; (e &amp; f) &gt;&gt; g</code></pre><h3 id="Independent-Branches"><a class="docs-heading-anchor" href="#Independent-Branches">Independent Branches</a><a id="Independent-Branches-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-Branches" title="Permalink"></a></h3><p>Process independent pipelines in parallel, then merge:</p><pre><code class="nohighlight hljs">  ┌─ fetch_a &gt;&gt; process_a ─┐
  │                        │
  ├─ fetch_b &gt;&gt; process_b ─┼── merge
  │                        │
  └─ fetch_c &gt;&gt; process_c ─┘</code></pre><pre><code class="language-julia hljs">fetch_a = @step fetch_a = sh&quot;fetch sample_a&quot;
process_a = @step process_a = sh&quot;process sample_a&quot;
fetch_b = @step fetch_b = sh&quot;fetch sample_b&quot;
process_b = @step process_b = sh&quot;process sample_b&quot;
fetch_c = @step fetch_c = sh&quot;fetch sample_c&quot;
process_c = @step process_c = sh&quot;process sample_c&quot;
merge = @step merge = sh&quot;merge results&quot;

branch_a = fetch_a &gt;&gt; process_a
branch_b = fetch_b &gt;&gt; process_b
branch_c = fetch_c &gt;&gt; process_c
pipeline = (branch_a &amp; branch_b &amp; branch_c) &gt;&gt; merge</code></pre><p>This pattern is common for processing multiple samples/files independently before combining results.</p><h2 id="Fallback:"><a class="docs-heading-anchor" href="#Fallback:">Fallback: <code>|</code></a><a id="Fallback:-1"></a><a class="docs-heading-anchor-permalink" href="#Fallback:" title="Permalink"></a></h2><p>The <code>|</code> operator provides fallback behavior—if the primary fails, run the fallback:</p><pre><code class="language-julia hljs"># If fast method fails, use slow method
fast_method = @step fast = sh&quot;fast_tool input.txt&quot;
slow_method = @step slow = sh&quot;slow_tool input.txt&quot;
pipeline = fast_method | slow_method

# Chain multiple fallbacks
method_a = @step a = sh&quot;method_a input&quot;
method_b = @step b = sh&quot;method_b input&quot;
method_c = @step c = sh&quot;method_c input&quot;
pipeline = method_a | method_b | method_c</code></pre><h2 id="Retry:-or-Retry()"><a class="docs-heading-anchor" href="#Retry:-or-Retry()">Retry: <code>^</code> or <code>Retry()</code></a><a id="Retry:-or-Retry()-1"></a><a class="docs-heading-anchor-permalink" href="#Retry:-or-Retry()" title="Permalink"></a></h2><p>Retry a node up to N times on failure:</p><pre><code class="language-julia hljs"># Using ^ operator (concise) – retry flaky step up to 3 times
flaky_api_call = @step api = sh&quot;echo &#39;mock response&#39;&quot;
pipeline = flaky_api_call^3

# Using Retry() with delay between attempts
network_request = @step fetch = sh&quot;echo &#39;data&#39;&quot;
pipeline = Retry(network_request, 5, delay=2.0)

# Combine with fallback
primary = @step primary = sh&quot;echo primary&quot;
fallback = @step fallback = sh&quot;echo fallback&quot;
pipeline = primary^3 | fallback</code></pre><h2 id="Branch-(Conditional)"><a class="docs-heading-anchor" href="#Branch-(Conditional)">Branch (Conditional)</a><a id="Branch-(Conditional)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-(Conditional)" title="Permalink"></a></h2><p>Execute different branches based on a runtime condition:</p><pre><code class="language-julia hljs"># Branch based on file size
large_file_pipeline = @step large = sh&quot;process_large data.txt&quot;
small_file_pipeline = @step small = sh&quot;process_small data.txt&quot;
pipeline = Branch(
    () -&gt; filesize(&quot;data.txt&quot;) &gt; 1_000_000,
    large_file_pipeline,
    small_file_pipeline
)

# Branch based on environment
debug_steps = @step debug = sh&quot;run with verbose logging&quot;
normal_steps = @step normal = sh&quot;run quietly&quot;
pipeline = Branch(
    () -&gt; haskey(ENV, &quot;DEBUG&quot;),
    debug_steps,
    normal_steps
)</code></pre><h2 id="Timeout"><a class="docs-heading-anchor" href="#Timeout">Timeout</a><a id="Timeout-1"></a><a class="docs-heading-anchor-permalink" href="#Timeout" title="Permalink"></a></h2><p>Fail if a node exceeds a time limit:</p><pre><code class="language-julia hljs"># 30 second timeout
long_running_step = @step long = sh&quot;sleep 1&quot;
pipeline = Timeout(long_running_step, 30.0)

# Combine with retry and fallback
api_call = @step api = sh&quot;echo result&quot;
backup = @step backup = sh&quot;echo fallback&quot;
pipeline = Timeout(api_call, 5.0)^3 | backup</code></pre><h2 id="ForEach-(pattern-or-collection)"><a class="docs-heading-anchor" href="#ForEach-(pattern-or-collection)">ForEach (pattern or collection)</a><a id="ForEach-(pattern-or-collection)-1"></a><a class="docs-heading-anchor-permalink" href="#ForEach-(pattern-or-collection)" title="Permalink"></a></h2><p>ForEach has two modes (dispatch on second argument). <strong>Collection:</strong> apply the block to each item (like Map). <strong>Pattern:</strong> discover files by pattern and run the block per match.</p><pre><code class="language-julia hljs"># Over a collection (list supplied in code)
samples = [&quot;sample_A&quot;, &quot;sample_B&quot;, &quot;sample_C&quot;]
pipeline = ForEach(samples) do s
    Step(Symbol(&quot;process_&quot;, s), sh(&quot;analyze $s.fastq&quot;))
end &gt;&gt; merge_results</code></pre><p><strong>Pattern-based discovery:</strong> ForEach(pattern) scans the filesystem; matching files must exist. Example with a temp dir:</p><pre><code class="language-julia hljs"># Create dummy files so ForEach can find matches (run in a temp dir)
cd(mktempdir()) do
    write(&quot;s1.fastq&quot;, &quot;&quot;); write(&quot;s2.fastq&quot;, &quot;&quot;)
    mkpath(&quot;fastq&quot;); write(&quot;fastq/s1_R1.fq.gz&quot;, &quot;&quot;); write(&quot;fastq/s2_R1.fq.gz&quot;, &quot;&quot;)
    mkpath(&quot;data/p1&quot;); write(&quot;data/p1/s1.csv&quot;, &quot;&quot;)

    # Single step per file - use sh(&quot;...&quot;) for interpolation
    ForEach(&quot;{sample}.fastq&quot;) do sample
        sh(&quot;process $(sample).fastq&quot;)
    end

    # Multi-step per file - chain with &gt;&gt;
    ForEach(&quot;fastq/{sample}_R1.fq.gz&quot;) do sample
        sh(&quot;pear $(sample)_R1 $(sample)_R2&quot;) &gt;&gt; sh(&quot;analyze $(sample)&quot;)
    end

    # Multiple wildcards
    ForEach(&quot;data/{project}/{sample}.csv&quot;) do project, sample
        sh(&quot;process $(project)/$(sample).csv&quot;)
    end

    # Chain with downstream merge
    ForEach(&quot;{id}.fastq&quot;) do id
        sh(&quot;align $(id).fastq&quot;)
    end &gt;&gt; @step merge = sh&quot;merge *.bam&quot;
end</code></pre><h2 id="Reduce-(Combine)"><a class="docs-heading-anchor" href="#Reduce-(Combine)">Reduce (Combine)</a><a id="Reduce-(Combine)-1"></a><a class="docs-heading-anchor-permalink" href="#Reduce-(Combine)" title="Permalink"></a></h2><p>Collect outputs from parallel steps and combine them:</p><pre><code class="language-julia hljs"># Combine parallel outputs with a function (define steps first)
analyze_a = @step a = sh&quot;echo result_a&quot;
analyze_b = @step b = sh&quot;echo result_b&quot;
pipeline = Reduce(analyze_a &amp; analyze_b) do outputs
    join(outputs, &quot;\n&quot;)
end

# Using a named function (define reducer and steps first)
combine_results(outputs) = join(outputs, &quot;\n&quot;)
step_a = @step a = sh&quot;echo result_a&quot;
step_b = @step b = sh&quot;echo result_b&quot;
step_c = @step c = sh&quot;echo result_c&quot;
pipeline = Reduce(combine_results, step_a &amp; step_b &amp; step_c)

# In a pipeline: fetch -&gt; parallel analysis -&gt; reduce -&gt; report
merge_outputs(outputs) = join(outputs, &quot;\n&quot;)
fetch = @step fetch = sh&quot;echo data&quot;
analyze_a = @step a = sh&quot;wc -c&quot;
analyze_b = @step b = sh&quot;wc -l&quot;
report = @step report = sh&quot;echo done&quot;
pipeline = fetch &gt;&gt; Reduce(merge_outputs, analyze_a &amp; analyze_b) &gt;&gt; report</code></pre><p>The reducer function receives a vector of outputs from all successful parallel steps (type depends on what the upstream steps return).</p><h3 id="Low-memory-/-large-data"><a class="docs-heading-anchor" href="#Low-memory-/-large-data">Low-memory / large data</a><a id="Low-memory-/-large-data-1"></a><a class="docs-heading-anchor-permalink" href="#Low-memory-/-large-data" title="Permalink"></a></h3><p>To avoid holding many large outputs in memory: (1) Have each step write its result to a file and <strong>return the path</strong> (e.g. <code>String</code>). (2) The reducer then receives a vector of paths and can open/process one at a time (or stream), write the combined result to a file, and return that path. (3) Use <code>run(pipeline; keep_outputs=:last)</code> so the returned <code>results</code> vector only retains the final step&#39;s <code>.result</code>; other steps get <code>.result === nothing</code>. You still get success, duration, and inputs/outputs per step; only the large values are dropped. Use <code>keep_outputs=:none</code> to drop all result values.</p><h2 id="Running-Pipelines"><a class="docs-heading-anchor" href="#Running-Pipelines">Running Pipelines</a><a id="Running-Pipelines-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Pipelines" title="Permalink"></a></h2><p>Use <code>run(pipeline)</code> or <code>pipeline |&gt; run</code>:</p><pre><code class="language-julia hljs"># Basic execution
results = run(pipeline)

# Silent (no progress output)
results = run(pipeline, verbose=false)

# Dry run (preview structure)
run(pipeline, dry_run=true)

# Named pipeline
step_a = @step a = sh&quot;first&quot;
step_b = @step b = sh&quot;second&quot;
p = Pipeline(step_a &gt;&gt; step_b, name=&quot;My Workflow&quot;)
run(p)</code></pre><h2 id="Checking-Results"><a class="docs-heading-anchor" href="#Checking-Results">Checking Results</a><a id="Checking-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-Results" title="Permalink"></a></h2><pre><code class="language-julia hljs">results = run(pipeline)

for r in results
    if r.success
        println(&quot;$(r.step.name): completed in $(r.duration)s&quot;)
    else
        println(&quot;$(r.step.name): FAILED - $(r.result)&quot;)
    end
end

# Check overall success
all_ok = all(r -&gt; r.success, results)</code></pre><h2 id="Mixing-Shell-and-Julia"><a class="docs-heading-anchor" href="#Mixing-Shell-and-Julia">Mixing Shell and Julia</a><a id="Mixing-Shell-and-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Mixing-Shell-and-Julia" title="Permalink"></a></h2><p>Shell commands and Julia functions compose seamlessly:</p><pre><code class="language-julia hljs"># Julia: prepare data (e.g. filter non-empty lines)
prep = @step prep = () -&gt; begin
    raw = read(&quot;raw.csv&quot;, String)
    cleaned = filter(line -&gt; !isempty(strip(line)), split(raw, &#39;\n&#39;))
    write(&quot;clean.csv&quot;, join(cleaned, &#39;\n&#39;))
    return &quot;Wrote $(length(cleaned)) lines&quot;
end

# Shell: run external tool
external = @step tool = sh&quot;wc -l clean.csv &gt; result.txt&quot;  # sh&quot;...&quot; for redirection

# Julia: postprocess
post = @step post = () -&gt; begin
    n = parse(Int, split(read(&quot;result.txt&quot;, String))[1])
    return &quot;Line count: $n&quot;
end

pipeline = prep &gt;&gt; external &gt;&gt; post
run(pipeline)</code></pre><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Count steps in a pipeline
n = count_steps(pipeline)

# Get all steps as a vector
all_steps = steps(pipeline)

# Print DAG structure
print_dag(pipeline)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 08:53">Wednesday 18 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
